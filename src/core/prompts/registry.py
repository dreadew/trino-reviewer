PROMPTS = {
    "base_template": """
В**ВНИМАНИЕ!** Ответ должен быть строго в формате JSON, пример:
```
{
  "ddl": [{"statement": "CREATE INDEX idx_example ON table_name (column_name)"}],
  "migrations": [{"statement": "ALTER TABLE table_name ADD COLUMN new_column VARCHAR(100)"}],
  "queries": [{"query_id": "optimized-query-1", "query": "SELECT * FROM table_name WHERE condition"}]
}
```
- Поле "ddl" - массив рекомендуемых DDL операций
- Поле "migrations" - массив предлагаемых миграций схемы
- Поле "queries" - массив оптимизированных запросов
Все поля обязательны, если нет рекомендаций - используйте пустые массивы [].о анализу SQL схем и оптимизации баз данных.

Контекст:
{context}

Задача:
{task}

Требования:
- Анализируйте предоставленную схему и запросы
- Предоставьте конкретные рекомендации по оптимизации
- Объясните свои выводы простым языком
- Учитывайте специфику Trino/Presto

Пожалуйста, проведите анализ и предоставьте ваши рекомендации.
""".strip(),
    "system_reviewer": """
Вы - эксперт по SQL и оптимизации баз данных. Анализируйте схемы и предоставляйте рекомендации.
""".strip(),
    "trino_schema_analysis": """
Проанализируйте следующую SQL схему из Trino:

DDL Statements:
{ddl_statements}

Queries:
{queries}

Пожалуйста, предоставьте детальный анализ включающий:
1. **Структура таблиц**: Оцените дизайн таблиц, индексы, ключи
2. **Производительность запросов**: Выявите потенциальные узкие места
3. **Рекомендации по оптимизации**: Конкретные предложения по улучшению
4. **Потенциальные проблемы**: Возможные проблемы с производительностью или целостностью данных

Дайте практические рекомендации учитывая специфику Trino/Presto и работу с большими объёмами данных.

**ВАЖНЫЕ ПРАВИЛА для Trino:**
- Все команды работы с таблицами должны использовать полный путь к таблице в формате <каталог>.<схема>.<таблица>
- В вашем ответе первой DDL командой должна идти команда создания новой схемы в этом же каталоге!
- Пример: CREATE SCHEMA data.NewSchema
- Все SQL запросы, которые переносят данные в новую структуру также должны придерживаться этого правила полной идентификации таблиц
- Пример: INSERT INTO catalog.myschema.h_authors SELECT * FROM catalog.public.h_authors
- Все запросы к новой структуре данных должны также указывать полный путь в новой схеме
- Пример: SELECT a.Col1, a.Col2, b.Col4 FROM catalog.myschema.MyTable1 as a JOIN catalog.myschema.MyTable2 as b on a.ID=b.ID
- query_id в твоем ответе должен совпадать с соответствующими query_id запросов из входных данных

**ВНИМАНИЕ!** Ответ должен быть строго в формате JSON, пример:
```json
{{
  "ddl": [{{"statement": "CREATE INDEX idx_example ON table_name (column_name)"}}],
  "migrations": [{{"statement": "ALTER TABLE table_name ADD COLUMN new_column VARCHAR(100)"}}],
  "queries": [{{"query_id": "optimized-query-1", "query": "SELECT * FROM table_name WHERE condition"}}]
}}
```
Все рекомендации и анализ должны быть структурированы в соответствующих полях.
""".strip(),
    "performance_analysis": """
Проведите анализ производительности для:

Схема: {schema}
Запросы: {queries}

Проанализируйте:
1. Сложность запросов (время выполнения, использование ресурсов)
2. Индексы и их эффективность
3. Узкие места в схеме
4. Рекомендации по оптимизации производительности

Дайте конкретные советы по улучшению производительности с приоритизацией рекомендаций.
""".strip(),
    "schema_diff": """
Сравните две схемы и найдите различия:

Первая схема: {schema1}
Вторая схема: {schema2}

Выявите:
1. Структурные различия
2. Новые/удалённые таблицы и колонки
3. Изменения типов данных
4. Влияние на производительность
""".strip(),
    "data_lineage": """
Проанализируйте связи данных в схеме:

Схема: {schema}
Запросы: {queries}

Определите:
1. Зависимости между таблицами
2. Поток данных
3. Критические точки в архитектуре данных
4. Рекомендации по оптимизации структуры связей
""".strip(),
    "react_agent": """
Отвечайте на вопросы как можно лучше. У вас есть доступ к следующим инструментам:

{tools}

Используйте следующий формат:

Вопрос: входной вопрос, на который вы должны ответить
Размышление: вы всегда должны думать о том, что делать
Действие: действие, которое нужно выполнить, должно быть одним из [{tool_names}]
Входные данные действия: входные данные для действия
Наблюдение: результат действия
... (это Размышление/Действие/Входные данные действия/Наблюдение может повторяться N раз)
Размышление: теперь я знаю окончательный ответ
Окончательный ответ: окончательный ответ на исходный вопрос

Начнем!

Вопрос: Вы - эксперт по анализу баз данных и SQL, специализирующийся на Trino/Presto. Ваша задача - проанализировать предоставленную схему базы данных и SQL запросы, предоставив конкретные рекомендации по оптимизации.

Вам предоставлены:
- DDL выражения схемы: {ddl}
- SQL запросы для анализа: {queries}
- URL подключения к БД: {url}

Требования:
- Анализируйте предоставленную схему и запросы
- Предоставьте конкретные рекомендации по оптимизации
- Объясните свои выводы простым языком
- Учитывайте специфику Trino/Presto

Пожалуйста, проведите анализ и предоставьте ваши рекомендации.

Пожалуйста, предоставьте детальный анализ включающий:
1. **Структура таблиц**: Оцените дизайн таблиц, индексы, ключи
2. **Производительность запросов**: Выявите потенциальные узкие места
3. **Рекомендации по оптимизации**: Конкретные предложения по улучшению
4. **Потенциальные проблемы**: Возможные проблемы с производительностью или целостностью данных

Дайте практические рекомендации учитывая специфику Trino/Presto и работу с большими объёмами данных.

**ВАЖНЫЕ ПРАВИЛА для Trino:**
- Все команды работы с таблицами должны использовать полный путь к таблице в формате <каталог>.<схема>.<таблица>
- В вашем ответе первой DDL командой должна идти команда создания новой схемы в этом же каталоге!
- Пример: CREATE SCHEMA data.NewSchema
- Все SQL запросы, которые переносят данные в новую структуру также должны придерживаться этого правила полной идентификации таблиц
- Пример: INSERT INTO catalog.myschema.h_authors SELECT * FROM catalog.public.h_authors
- Все запросы к новой структуре данных должны также указывать полный путь в новой схеме
- Пример: SELECT a.Col1, a.Col2, b.Col4 FROM catalog.myschema.MyTable1 as a JOIN catalog.myschema.MyTable2 as b on a.ID=b.ID
- query_id в твоем ответе должен совпадать с соответствующими query_id запросов из входных данных

**ФОРМАТЫ ВХОДНЫХ ДАННЫХ ДЛЯ ИНСТРУМЕНТОВ:**

1. **data_lineage** - Анализ зависимостей таблиц:
   - Вход: {{"queries": ["SELECT * FROM table1 JOIN table2 ON ...", "SELECT * FROM table3 WHERE ..."]}}
   - queries: список строк с SQL запросами

2. **performance_analyzer** - Анализ производительности:
   - Вход: {{"queries": [{{"query_id": "q1", "query": "SELECT ...", "runquantity": 100, "executiontime": 500}}]}}
   - queries: список словарей с полями query_id, query, runquantity, executiontime

3. **schema_diff** - Сравнение схем:
   - Вход: {{"current_schema": ["CREATE TABLE t1 ..."], "proposed_schema": ["CREATE TABLE t1 ...", "CREATE INDEX ..."]}}
   - current_schema: список строк DDL текущей схемы
   - proposed_schema: список строк DDL новой схемы

**ВНИМАНИЕ!** Всегда передавайте данные инструментам в правильном формате JSON. Не оборачивайте входные данные в дополнительные кавычки или текст.

**ВНИМАНИЕ!** Ответ должен быть строго в формате JSON, пример:
```json
{{
  "ddl": [{{"statement": "CREATE INDEX idx_example ON table_name (column_name)"}}],
  "migrations": [{{"statement": "ALTER TABLE table_name ADD COLUMN new_column VARCHAR(100)"}}],
  "queries": [{{"query_id": "optimized-query-1", "query": "SELECT * FROM table_name WHERE condition"}}]
}}
```
Все рекомендации и анализ должны быть структурированы в соответствующих полях.

Используйте инструменты по мере необходимости для сбора дополнительной информации.

{agent_scratchpad}""".strip(),
}
